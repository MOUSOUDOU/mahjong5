# 設計書

## 概要

５枚麻雀ゲームは、ブラウザベースのWebアプリケーションとして実装します。シンプルなゲームルールに対応した軽量な設計で、２人のプレイヤーがリアルタイムで対戦できるシステムを構築します。

## アーキテクチャ

### システム構成

```
┌─────────────────┐    ┌─────────────────┐
│   プレイヤー１    │    │   プレイヤー２    │
│   (ブラウザ)     │    │   (ブラウザ)     │
└─────────┬───────┘    └─────────┬───────┘
          │                      │
          │      WebSocket       │
          │                      │
    ┌─────┴──────────────────────┴─────┐
    │        Node.js サーバー           │
    │    (Express + Socket.io)        │
    │                                 │
    │  ┌─────────────────────────────┐ │
    │  │      ゲームエンジン          │ │
    │  │   - 牌管理                  │ │
    │  │   - ルール判定              │ │
    │  │   - 状態管理                │ │
    │  └─────────────────────────────┘ │
    └───────────────────────────────────┘
```

### 技術スタック

- **フロントエンド**: HTML5, CSS3, JavaScript (Vanilla)
- **バックエンド**: Node.js + Express
- **リアルタイム通信**: Socket.io
- **状態管理**: メモリベース（永続化なし）

## コンポーネントと インターフェース

### 1. 牌（Tile）クラス

```javascript
class Tile {
  constructor(suit, value) {
    this.suit = suit;    // 'bamboo' | 'honor'
    this.value = value;  // 1-9 for bamboo, 'white'|'green'|'red' for honor
    this.id = `${suit}_${value}`;
  }
}
```

### 2. プレイヤー（Player）クラス

```javascript
class Player {
  constructor(id, name) {
    this.id = id;
    this.name = name;
    this.hand = [];           // 手牌（最大5枚）
    this.isRiichi = false;    // リーチ状態
    this.discardedTiles = []; // 捨て牌
  }
}
```

### 3. ゲーム（Game）クラス

```javascript
class Game {
  constructor() {
    this.players = [];        // プレイヤー配列
    this.deck = [];          // 山牌
    this.currentPlayerIndex = 0; // 現在の手番
    this.gameState = 'waiting'; // 'waiting'|'playing'|'finished'
    this.winner = null;
  }
}
```
#
## 4. ゲームエンジン（GameEngine）クラス

```javascript
class GameEngine {
  // 牌デッキの初期化
  initializeDeck()
  
  // 牌を配る
  dealTiles(game)
  
  // 牌を引く
  drawTile(game, playerId)
  
  // 牌を捨てる
  discardTile(game, playerId, tileId)
  
  // リーチ宣言
  declareRiichi(game, playerId)
  
  // 完成形判定
  checkWinningHand(tiles)
  
  // テンパイ判定
  checkTenpai(tiles)
  
  // ロン判定
  checkRon(game, playerId, discardedTile)
}
```

## データモデル

### 牌の種類定義

```javascript
const TILE_TYPES = {
  BAMBOO: {
    suit: 'bamboo',
    values: [1, 2, 3, 4, 5, 6, 7, 8, 9],
    count: 4 // 各数字4枚ずつ
  },
  HONOR: {
    suit: 'honor',
    values: ['white', 'green', 'red'],
    count: 4 // 各色4枚ずつ
  }
};
```

### ゲーム状態

```javascript
const GAME_STATES = {
  WAITING: 'waiting',     // プレイヤー待ち
  PLAYING: 'playing',     // ゲーム中
  FINISHED: 'finished'    // ゲーム終了
};

const PLAYER_ACTIONS = {
  DRAW: 'draw',           // 牌を引く
  DISCARD: 'discard',     // 牌を捨てる
  RIICHI: 'riichi',       // リーチ宣言
  RON: 'ron',             // ロン宣言
  TSUMO: 'tsumo'          // ツモ宣言
};
```

### 完成形パターン

５枚麻雀の完成形は以下のパターンのみ：

1. **順子 + 対子**: 連続する3枚 + 同じ牌2枚 (例: 123 + 44)
2. **刻子 + 対子**: 同じ牌3枚 + 同じ牌2枚 (例: 111 + 22)

## エラーハンドリング

### エラータイプ

```javascript
const ERROR_TYPES = {
  INVALID_MOVE: 'invalid_move',
  GAME_NOT_FOUND: 'game_not_found',
  PLAYER_NOT_FOUND: 'player_not_found',
  NOT_PLAYER_TURN: 'not_player_turn',
  INVALID_TILE: 'invalid_tile',
  RIICHI_REQUIRED: 'riichi_required',
  DECK_EMPTY: 'deck_empty'
};
```

### エラーハンドリング戦略

1. **クライアント側**: 無効な操作を事前にチェック
2. **サーバー側**: 全ての操作を検証し、適切なエラーメッセージを返す
3. **ユーザー体験**: エラーメッセージは日本語で分かりやすく表示

## テスト戦略

### 単体テスト

1. **牌クラス**: 牌の生成と識別
2. **完成形判定**: 各パターンの正確な判定
3. **テンパイ判定**: 待ち牌の正確な特定
4. **ゲームロジック**: ルールの正確な実装

### 統合テスト

1. **ゲームフロー**: 開始から終了までの一連の流れ
2. **プレイヤー間通信**: WebSocketでの状態同期
3. **エラーハンドリング**: 異常系の適切な処理

### 手動テスト

1. **ユーザビリティ**: 直感的な操作性
2. **レスポンシブ**: 異なる画面サイズでの表示
3. **ブラウザ互換性**: 主要ブラウザでの動作確認#
# ユーザーインターフェース設計

### メイン画面レイアウト

```
┌─────────────────────────────────────────────────────────┐
│                    ５枚麻雀                              │
├─────────────────────────────────────────────────────────┤
│  相手プレイヤー: [名前] [リーチ状態]                      │
│  相手の手牌: [?] [?] [?] [?]                            │
│                                                         │
│  捨て牌エリア:                                           │
│  [1] [3] [7] [白] [2] ...                              │
│                                                         │
│  残り牌数: 32枚                                          │
│  現在の手番: あなた                                       │
│                                                         │
│  あなたの手牌:                                           │
│  [1] [2] [3] [4] [5]                                   │
│                                                         │
│  [牌を引く] [リーチ] [上がり]                            │
└─────────────────────────────────────────────────────────┘
```

### 牌の表示

- **索子**: 数字と竹のアイコンで表現
- **字牌**: 白・發・中の漢字で表現
- **選択可能な牌**: ハイライト表示
- **捨て牌**: 時系列順に配置

### インタラクション

1. **牌を引く**: ボタンクリックで山から1枚引く
2. **牌を捨てる**: 手牌をクリックして選択・捨てる
3. **リーチ宣言**: テンパイ時にボタンが有効化
4. **ロン宣言**: 相手の捨て牌で上がれる時にボタン表示

## セキュリティ考慮事項

### データ保護

1. **手牌の秘匿**: 相手プレイヤーに手牌情報を送信しない
2. **操作検証**: サーバー側で全ての操作を検証
3. **不正防止**: クライアント側の改ざんを防ぐ

### 通信セキュリティ

1. **WebSocket接続**: 適切な認証とセッション管理
2. **入力検証**: 全ての入力データを検証
3. **レート制限**: 過度なリクエストを制限

## パフォーマンス最適化

### フロントエンド

1. **DOM操作の最小化**: 必要な部分のみ更新
2. **画像最適化**: 牌画像の軽量化
3. **キャッシュ活用**: 静的リソースのキャッシュ

### バックエンド

1. **メモリ効率**: 不要なゲームデータの削除
2. **計算最適化**: 完成形判定の高速化
3. **接続管理**: 非アクティブ接続の適切な処理

## 拡張性の考慮

### 将来的な機能追加

1. **観戦機能**: 第三者がゲームを観戦
2. **リプレイ機能**: ゲーム履歴の保存・再生
3. **ランキング**: プレイヤーの成績管理
4. **カスタムルール**: ルールのバリエーション

### 技術的拡張

1. **データベース**: 永続化が必要になった場合
2. **スケーリング**: 複数ゲーム同時実行
3. **モバイル対応**: レスポンシブデザインの強化